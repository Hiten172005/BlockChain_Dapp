{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-3958c4e126e0619d7688010d618faea9d9fc195d",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/FraudReportLedger.sol": "project/contracts/FraudReportLedger.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/FraudReportLedger.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title FraudReportLedger\n * @notice This contract implements staking and reward mechanisms for fraud reporting and validation.\n *\n * @dev Why would banks use this chain?\n * - Banks stake ETH to submit and validate reports, earning rewards for honest participation.\n * - Correct reporters and validators share the stakes of incorrect participants.\n * - Transparent, decentralized fraud reporting increases trust and reduces risk.\n * - Future: Extend with token incentives, reputation scores, or privileged access for high-performing banks.\n */\n\ninterface IBankRegistry {\n    function isBankRegistered(\n        address _bankAddress\n    ) external view returns (bool);\n}\n\ncontract FraudReportLedger {\n    // --- Enums ---\n    enum ReportStatus {\n        PENDING,\n        APPROVED,\n        DISPUTED,\n        FINALIZED\n    }\n    enum VoteType {\n        APPROVE,\n        DISPUTE\n    }\n\n    // --- State Variables ---\n    address public bankRegistryAddress;\n\n    // Staking and Fee amounts\n    uint256 public constant REPORTER_STAKE = 32 ether;\n    uint256 public constant VALIDATOR_STAKE = 32 ether;\n    uint256 public constant LOCK_PERIOD = 1 minutes;\n    uint256 public constant SCORE_QUERY_FEE = 0.003 ether;\n    uint256 public constant REPORT_PURCHASE_FEE_PER_REPORT = 0.0005 ether;\n    uint256 public constant MAJORITY_INCENTIVE = 0.003 ether;\n\n    // --- Structs ---\n    struct Report {\n        uint256 reportId;\n        address customerAddress;\n        string ipfsCID;\n        address reportingBank;\n        uint256 timestamp;\n        uint256 reporterStake; // Amount staked by reporter\n        uint256 finalizeTime; // When voting ends (timestamp + 48 hours)\n        ReportStatus status; // Current status\n        bool isFinalized; // Has voting ended?\n    }\n\n    struct Validation {\n        address validator;\n        uint256 stake;\n        VoteType vote;\n        uint256 timestamp;\n    }\n\n    // --- Mappings ---\n    mapping(uint256 => Report) public reports;\n    uint256 public reportCounter;\n    mapping(address => uint256[]) public customerFraudReportIds;\n\n    // Validation tracking\n    mapping(uint256 => Validation[]) public reportValidations;\n    mapping(uint256 => mapping(address => bool)) public hasVoted;\n\n    // Stats tracking\n    mapping(address => uint256) public bankRewardsEarned;\n    mapping(address => uint256) public bankStakesLost;\n    uint256 public accumulatedFees;\n    address public owner;\n\n    // --- Events ---\n    event ReportSubmitted(\n        uint256 indexed reportId,\n        address indexed customerAddress,\n        address indexed bankAddress,\n        string ipfsCID,\n        uint256 stake\n    );\n\n    event ReportValidated(\n        uint256 indexed reportId,\n        address indexed validator,\n        VoteType vote,\n        uint256 stake\n    );\n\n    event ReportFinalized(\n        uint256 indexed reportId,\n        ReportStatus finalStatus,\n        uint256 approveCount,\n        uint256 disputeCount\n    );\n\n    event StakeReturned(address indexed recipient, uint256 amount);\n\n    event RewardDistributed(address indexed recipient, uint256 amount);\n\n    event FeesWithdrawn(address indexed owner, uint256 amount);\n\n    event QueryFeePaid(address indexed payer, uint256 amount);\n\n    // --- Modifiers ---\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    // --- Constructor ---\n    constructor(address _bankRegistryAddress) {\n        require(_bankRegistryAddress != address(0), \"Invalid registry address\");\n        bankRegistryAddress = _bankRegistryAddress;\n        owner = msg.sender;\n    }\n\n    // --- Functions ---\n\n    /**\n     * @notice Allows a registered bank to submit a new fraud report with staking.\n     * @param _customerAddress The wallet address of the customer involved.\n     * @param _ipfsCID The IPFS Content ID (CID) of the evidence file.\n     */\n    function submitReport(\n        address _customerAddress,\n        string memory _ipfsCID\n    ) external payable {\n        require(\n            IBankRegistry(bankRegistryAddress).isBankRegistered(msg.sender),\n            \"Caller is not a registered bank\"\n        );\n        require(_customerAddress != address(0), \"Invalid customer address\");\n        require(bytes(_ipfsCID).length > 0, \"IPFS CID cannot be empty\");\n        require(bytes(_ipfsCID).length >= 46, \"Invalid IPFS CID format\");\n        require(msg.value >= REPORTER_STAKE, \"Insufficient stake amount\");\n\n        reportCounter++;\n\n        reports[reportCounter] = Report({\n            reportId: reportCounter,\n            customerAddress: _customerAddress,\n            ipfsCID: _ipfsCID,\n            reportingBank: msg.sender,\n            timestamp: block.timestamp,\n            reporterStake: msg.value,\n            finalizeTime: block.timestamp + LOCK_PERIOD,\n            status: ReportStatus.PENDING,\n            isFinalized: false\n        });\n\n        customerFraudReportIds[_customerAddress].push(reportCounter);\n\n        emit ReportSubmitted(\n            reportCounter,\n            _customerAddress,\n            msg.sender,\n            _ipfsCID,\n            msg.value\n        );\n    }\n\n    /**\n     * @notice Allows registered banks to validate a report by voting.\n     * @param _reportId The ID of the report to validate.\n     * @param _vote The vote (APPROVE or DISPUTE).\n     */\n    function validateReport(\n        uint256 _reportId,\n        VoteType _vote\n    ) external payable {\n        require(\n            IBankRegistry(bankRegistryAddress).isBankRegistered(msg.sender),\n            \"Caller is not a registered bank\"\n        );\n        require(\n            _reportId > 0 && _reportId <= reportCounter,\n            \"Invalid report ID\"\n        );\n        require(msg.value >= VALIDATOR_STAKE, \"Insufficient stake amount\");\n        require(\n            !hasVoted[_reportId][msg.sender],\n            \"Already voted on this report\"\n        );\n\n        Report storage report = reports[_reportId];\n        require(!report.isFinalized, \"Report already finalized\");\n        require(block.timestamp < report.finalizeTime, \"Voting period ended\");\n        require(\n            msg.sender != report.reportingBank,\n            \"Cannot validate own report\"\n        );\n\n        // Record validation\n        reportValidations[_reportId].push(\n            Validation({\n                validator: msg.sender,\n                stake: msg.value,\n                vote: _vote,\n                timestamp: block.timestamp\n            })\n        );\n\n        hasVoted[_reportId][msg.sender] = true;\n\n        emit ReportValidated(_reportId, msg.sender, _vote, msg.value);\n    }\n\n    /**\n     * @notice Finalizes a report after the lock period and distributes stakes.\n     * @param _reportId The ID of the report to finalize.\n     */\n    function finalizeReport(uint256 _reportId) external {\n        require(\n            _reportId > 0 && _reportId <= reportCounter,\n            \"Invalid report ID\"\n        );\n\n        Report storage report = reports[_reportId];\n        require(!report.isFinalized, \"Report already finalized\");\n        require(block.timestamp >= report.finalizeTime, \"Lock period not over\");\n\n        // Count votes\n        Validation[] storage validations = reportValidations[_reportId];\n        uint256 approveCount = 0;\n        uint256 disputeCount = 0;\n\n        for (uint256 i = 0; i < validations.length; i++) {\n            if (validations[i].vote == VoteType.APPROVE) {\n                approveCount++;\n            } else {\n                disputeCount++;\n            }\n        }\n\n        // Determine outcome (majority wins, tie goes to DISPUTED)\n        bool approved = approveCount > disputeCount;\n        report.status = approved\n            ? ReportStatus.APPROVED\n            : ReportStatus.DISPUTED;\n        report.isFinalized = true;\n\n        // Distribute stakes\n        _distributeStakes(_reportId, approved);\n\n        emit ReportFinalized(\n            _reportId,\n            report.status,\n            approveCount,\n            disputeCount\n        );\n    }\n\n    /**\n     * @notice Internal function to distribute stakes after finalization.\n     * @param _reportId The report ID.\n     * @param approved Whether the report was approved.\n     */\n    function _distributeStakes(uint256 _reportId, bool approved) internal {\n        Report storage report = reports[_reportId];\n        Validation[] storage validations = reportValidations[_reportId];\n\n        bool reporterIsWinner = approved; // Reporter wins if report is approved\n\n        // Track majority and minority validators\n        address[] memory majorityValidators = new address[](validations.length);\n        uint256 majorityCount = 0;\n        address[] memory minorityValidators = new address[](validations.length);\n        uint256 minorityCount = 0;\n\n        for (uint256 i = 0; i < validations.length; i++) {\n            bool votedCorrectly = (approved &&\n                validations[i].vote == VoteType.APPROVE) ||\n                (!approved && validations[i].vote == VoteType.DISPUTE);\n\n            if (votedCorrectly) {\n                majorityValidators[majorityCount] = validations[i].validator;\n                majorityCount++;\n            } else {\n                minorityValidators[minorityCount] = validations[i].validator;\n                minorityCount++;\n                bankStakesLost[validations[i].validator] += validations[i]\n                    .stake;\n            }\n        }\n\n        // Handle reporter\n        if (reporterIsWinner) {\n            // Reporter gets stake + incentive\n            payable(report.reportingBank).transfer(\n                report.reporterStake + MAJORITY_INCENTIVE\n            );\n            bankRewardsEarned[report.reportingBank] += MAJORITY_INCENTIVE;\n            emit StakeReturned(report.reportingBank, report.reporterStake);\n            emit RewardDistributed(report.reportingBank, MAJORITY_INCENTIVE);\n        } else {\n            // Reporter loses stake\n            bankStakesLost[report.reportingBank] += report.reporterStake;\n        }\n\n        // Majority validators get stake + incentive\n        for (uint256 i = 0; i < majorityCount; i++) {\n            payable(majorityValidators[i]).transfer(\n                VALIDATOR_STAKE + MAJORITY_INCENTIVE\n            );\n            bankRewardsEarned[majorityValidators[i]] += MAJORITY_INCENTIVE;\n            emit StakeReturned(majorityValidators[i], VALIDATOR_STAKE);\n            emit RewardDistributed(majorityValidators[i], MAJORITY_INCENTIVE);\n        }\n\n        // Minority validators lose stake (already tracked above)\n        // No payout to minority\n    }\n\n    /**\n     * @notice Payable function to retrieve all fraud reports for a customer. Charges a query fee.\n     */\n    function getReportsForCustomer(\n        address _customerAddress\n    ) external payable returns (Report[] memory) {\n        require(\n            msg.value >= SCORE_QUERY_FEE,\n            \"Insufficient fee for report query\"\n        );\n        accumulatedFees += msg.value;\n        emit QueryFeePaid(msg.sender, msg.value);\n\n        uint256[] memory reportIds = customerFraudReportIds[_customerAddress];\n        Report[] memory customerReports = new Report[](reportIds.length);\n\n        for (uint i = 0; i < reportIds.length; i++) {\n            customerReports[i] = reports[reportIds[i]];\n        }\n\n        return customerReports;\n    }\n\n    /**\n     * @notice Get the total number of fraud reports for a customer.\n     * @param _customerAddress The address of the customer.\n     * @return The count of fraud reports.\n     */\n    function getReportCount(\n        address _customerAddress\n    ) external view returns (uint256) {\n        return customerFraudReportIds[_customerAddress].length;\n    }\n\n    /**\n     * @notice Get a specific report by its ID.\n     * @param _reportId The ID of the report.\n     * @return The report details.\n     */\n    function getReport(\n        uint256 _reportId\n    ) external view returns (Report memory) {\n        require(\n            _reportId > 0 && _reportId <= reportCounter,\n            \"Invalid report ID\"\n        );\n        return reports[_reportId];\n    }\n\n    /**\n     * @notice Get all report IDs for a customer.\n     * @param _customerAddress The address of the customer.\n     * @return Array of report IDs.\n     */\n    function getReportIds(\n        address _customerAddress\n    ) external view returns (uint256[] memory) {\n        return customerFraudReportIds[_customerAddress];\n    }\n\n    /**\n     * @notice Get all validations for a report.\n     * @param _reportId The report ID.\n     * @return Array of validations.\n     */\n    function getReportValidations(\n        uint256 _reportId\n    ) external view returns (Validation[] memory) {\n        return reportValidations[_reportId];\n    }\n\n    /**\n     * @notice Get vote counts for a report.\n     * @param _reportId The report ID.\n     * @return approveCount Number of APPROVE votes.\n     * @return disputeCount Number of DISPUTE votes.\n     */\n    function getVoteCounts(\n        uint256 _reportId\n    ) external view returns (uint256 approveCount, uint256 disputeCount) {\n        Validation[] storage validations = reportValidations[_reportId];\n\n        for (uint256 i = 0; i < validations.length; i++) {\n            if (validations[i].vote == VoteType.APPROVE) {\n                approveCount++;\n            } else {\n                disputeCount++;\n            }\n        }\n\n        return (approveCount, disputeCount);\n    }\n\n    /**\n     * @notice Check if a report can be finalized.\n     * @param _reportId The report ID.\n     * @return Whether the report can be finalized.\n     */\n    function canFinalize(uint256 _reportId) external view returns (bool) {\n        if (_reportId == 0 || _reportId > reportCounter) return false;\n\n        Report storage report = reports[_reportId];\n        return !report.isFinalized && block.timestamp >= report.finalizeTime;\n    }\n\n    /**\n     * @notice Get all pending reports (not finalized).\n     * @return Array of pending report IDs.\n     */\n    function getPendingReports() external view returns (uint256[] memory) {\n        uint256 pendingCount = 0;\n\n        // First, count pending reports\n        for (uint256 i = 1; i <= reportCounter; i++) {\n            if (!reports[i].isFinalized) {\n                pendingCount++;\n            }\n        }\n\n        // Then, collect them\n        uint256[] memory pendingReports = new uint256[](pendingCount);\n        uint256 index = 0;\n\n        for (uint256 i = 1; i <= reportCounter; i++) {\n            if (!reports[i].isFinalized) {\n                pendingReports[index] = i;\n                index++;\n            }\n        }\n\n        return pendingReports;\n    }\n\n    /**\n     * @notice Get reports ready for finalization.\n     * @return Array of report IDs ready to finalize.\n     */\n    function getFinalizableReports() external view returns (uint256[] memory) {\n        uint256 finalizableCount = 0;\n\n        // Count finalizable reports\n        for (uint256 i = 1; i <= reportCounter; i++) {\n            if (\n                !reports[i].isFinalized &&\n                block.timestamp >= reports[i].finalizeTime\n            ) {\n                finalizableCount++;\n            }\n        }\n\n        // Collect them\n        uint256[] memory finalizableReports = new uint256[](finalizableCount);\n        uint256 index = 0;\n\n        for (uint256 i = 1; i <= reportCounter; i++) {\n            if (\n                !reports[i].isFinalized &&\n                block.timestamp >= reports[i].finalizeTime\n            ) {\n                finalizableReports[index] = i;\n                index++;\n            }\n        }\n\n        return finalizableReports;\n    }\n\n    /**\n     * @notice Get bank statistics.\n     * @param _bankAddress The bank address.\n     * @return reportsSubmitted Number of reports submitted.\n     * @return validationsMade Number of validations made.\n     * @return rewardsEarned Total rewards earned.\n     * @return stakesLost Total stakes lost.\n     */\n    function getBankStats(\n        address _bankAddress\n    )\n        external\n        view\n        returns (\n            uint256 reportsSubmitted,\n            uint256 validationsMade,\n            uint256 rewardsEarned,\n            uint256 stakesLost\n        )\n    {\n        // Count reports submitted\n        for (uint256 i = 1; i <= reportCounter; i++) {\n            if (reports[i].reportingBank == _bankAddress) {\n                reportsSubmitted++;\n            }\n        }\n\n        // Count validations made\n        for (uint256 i = 1; i <= reportCounter; i++) {\n            if (hasVoted[i][_bankAddress]) {\n                validationsMade++;\n            }\n        }\n\n        return (\n            reportsSubmitted,\n            validationsMade,\n            bankRewardsEarned[_bankAddress],\n            bankStakesLost[_bankAddress]\n        );\n    }\n\n    /**\n     * @notice Calculate fraud score for a customer (0-100). Free to call.\n     * @param _customerAddress The customer address.\n     * @return score The fraud score (0 = highest risk, 100 = clean).\n     */\n    function getFraudScore(\n        address _customerAddress\n    ) public view returns (uint256 score) {\n        uint256 approvedReportCount = 0;\n        uint256[] memory reportIds = customerFraudReportIds[_customerAddress];\n\n        for (uint i = 0; i < reportIds.length; i++) {\n            if (reports[reportIds[i]].status == ReportStatus.APPROVED) {\n                approvedReportCount++;\n            }\n        }\n\n        if (approvedReportCount == 0) return 100; // CLEAN\n        if (approvedReportCount == 1) return 75; // LOW RISK\n        if (approvedReportCount == 2) return 55; // LOW-MEDIUM RISK\n        if (approvedReportCount <= 5) return 35; // MEDIUM RISK\n        return 10; // HIGH RISK\n    }\n\n    /**\n     * @notice Payable function to get a customer's fraud score.\n     * @param _customerAddress The customer address.\n     * @return score The fraud score.\n     */\n    function getFraudScorePayable(\n        address _customerAddress\n    ) external payable returns (uint256 score) {\n        require(\n            msg.value >= SCORE_QUERY_FEE,\n            \"Insufficient fee for score query\"\n        );\n        accumulatedFees += msg.value;\n        emit QueryFeePaid(msg.sender, msg.value);\n        return getFraudScore(_customerAddress);\n    }\n\n    /**\n     * @notice Purchase access to all report CIDs for a customer.\n     * @param _customerAddress The customer address.\n     * @return An array of IPFS CIDs.\n     */\n    function purchaseReportDetails(\n        address _customerAddress\n    ) external payable returns (string[] memory) {\n        uint256[] memory reportIds = customerFraudReportIds[_customerAddress];\n        uint256 requiredFee = reportIds.length * REPORT_PURCHASE_FEE_PER_REPORT;\n        require(\n            msg.value >= requiredFee,\n            \"Insufficient fee for report details\"\n        );\n\n        accumulatedFees += msg.value;\n\n        string[] memory cids = new string[](reportIds.length);\n        for (uint i = 0; i < reportIds.length; i++) {\n            cids[i] = reports[reportIds[i]].ipfsCID;\n        }\n\n        return cids;\n    }\n\n    /**\n     * @notice Allows the owner to withdraw accumulated fees.\n     */\n    function withdrawFees() external onlyOwner {\n        uint256 amount = accumulatedFees;\n        require(amount > 0, \"No fees to withdraw\");\n\n        accumulatedFees = 0;\n        payable(owner).transfer(amount);\n\n        emit FeesWithdrawn(owner, amount);\n    }\n}\n"
      }
    }
  }
}